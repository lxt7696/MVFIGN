# mpc_utils.py - 修复版本
# 主要改进：
# 1. 优先从文件读取输出（更可靠）
# 2. 改进stdout解析逻辑
# 3. 添加更详细的调试信息

import subprocess
import numpy as np
import torch
import os
import time
import re

class MPSPDZManager:
    """MP-SPDZ 安全计算管理器（修复版）"""
    
    def __init__(self, party_id, mpspdz_root="/home/lxt/project/MVFIGN/MP-SPDZ"):
        self.party_id = party_id
        self.mpspdz_root = mpspdz_root
        self.player_data_dir = os.path.join(mpspdz_root, "Player-Data")
        
        os.makedirs(self.player_data_dir, exist_ok=True)
        
        print(f"[Party {party_id}] MPC Manager initialized")
        print(f"  MP-SPDZ Root: {mpspdz_root}")
        print(f"  Player Data: {self.player_data_dir}")
        
    def write_inputs(self, data_dict, session_id=0):
        """将数据写入 MP-SPDZ 输入文件"""
        input_file = os.path.join(
            self.player_data_dir, 
            f"Input-P{self.party_id}-{session_id}"
        )
        
        values = []
        
        # Party 0 提供 A 和 W
        if self.party_id == 0:
            if 'A' in data_dict and data_dict['A'] is not None:
                A = self._to_numpy(data_dict['A'])
                values.extend(A.flatten().tolist())
                print(f"[Party {self.party_id}] A shape: {A.shape}, values: {len(A.flatten())}")
            
            if 'W' in data_dict and data_dict['W'] is not None:
                W = self._to_numpy(data_dict['W'])
                values.extend(W.flatten().tolist())
                print(f"[Party {self.party_id}] W shape: {W.shape}, values: {len(W.flatten())}")
        
        # Party 1 提供 B
        else:
            if 'B' in data_dict and data_dict['B'] is not None:
                B = self._to_numpy(data_dict['B'])
                values.extend(B.flatten().tolist())
                print(f"[Party {self.party_id}] B shape: {B.shape}, values: {len(B.flatten())}")
        
        # 写入文件（每行一个值）
        with open(input_file, 'w') as f:
            for val in values:
                f.write(f"{float(val)}\n")
        
        print(f"[Party {self.party_id}] Wrote {len(values)} values to {input_file}")
        return len(values)
    
    def _to_numpy(self, tensor):
        """转换为 numpy 数组"""
        if isinstance(tensor, torch.Tensor):
            return tensor.detach().cpu().numpy()
        return np.array(tensor)
    
    def read_outputs_from_file(self, shape, session_id=0):
        """
        从文件读取输出（最可靠的方法）
        MP-SPDZ 使用 print_float_to_file 会创建 Output-P<party_id>-<session_id> 文件
        """
        output_file = os.path.join(
            self.player_data_dir,
            f"Output-P{self.party_id}-{session_id}"
        )
        
        # 等待文件生成（最多等待5秒）
        max_wait = 5
        waited = 0
        while not os.path.exists(output_file) and waited < max_wait:
            time.sleep(0.1)
            waited += 0.1
        
        if not os.path.exists(output_file):
            raise FileNotFoundError(
                f"[Party {self.party_id}] Output file not found: {output_file}"
            )
        
        print(f"[Party {self.party_id}] Reading from {output_file}")
        
        # 读取文件
        values = []
        with open(output_file, 'r') as f:
            for line in f:
                line = line.strip()
                if line:
                    try:
                        val = float(line)
                        values.append(val)
                    except ValueError:
                        print(f"[Party {self.party_id}] Warning: Could not parse line: {line}")
        
        expected_size = shape[0] * shape[1]
        print(f"[Party {self.party_id}] Read {len(values)} values (expected {expected_size})")
        
        if len(values) != expected_size:
            raise ValueError(
                f"[Party {self.party_id}] Size mismatch: got {len(values)}, expected {expected_size}"
            )
        
        # 转换为tensor
        result = np.array(values).reshape(shape)
        return torch.from_numpy(result).float()
    
    def read_outputs_from_stdout(self, stdout, shape):
        """从标准输出解析结果（备用方法）"""
        lines = stdout.strip().split('\n')
        values = []
        capturing = False
        
        for line in lines:
            line = line.strip()
            
            # 查找新的标记
            if 'RESULT_START' in line:
                capturing = True
                print(f"[Party {self.party_id}] Found RESULT_START")
                continue
            
            if 'RESULT_END' in line:
                capturing = False
                print(f"[Party {self.party_id}] Found RESULT_END")
                break
            
            # 在捕获区域内解析数值
            if capturing and line:
                try:
                    # 尝试提取数字（包括科学计数法）
                    match = re.search(r'[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?', line)
                    if match:
                        val = float(match.group())
                        values.append(val)
                except (ValueError, AttributeError) as e:
                    print(f"[Party {self.party_id}] Could not parse: {line}")
                    continue
        
        if len(values) == 0:
            print(f"[Party {self.party_id}] No output values found in stdout!")
            print(f"[Party {self.party_id}] Full stdout (first 2000 chars):")
            print(stdout[:2000])
            raise ValueError("No output values found in stdout")
        
        expected_size = shape[0] * shape[1]
        print(f"[Party {self.party_id}] Parsed {len(values)} values from stdout (expected {expected_size})")
        
        if len(values) != expected_size:
            print(f"[Party {self.party_id}] Warning: Size mismatch!")
            if len(values) < expected_size:
                values.extend([0.0] * (expected_size - len(values)))
            else:
                values = values[:expected_size]
        
        result = np.array(values).reshape(shape)
        return torch.from_numpy(result).float()
    
    def compile_program(self, program_name="secure_matmul"):
        """编译 MPC 程序"""
        compile_cmd = f"cd {self.mpspdz_root} && ./compile.py -R 64 {program_name}"
        
        print(f"[Party {self.party_id}] Compiling {program_name}...")
        
        result = subprocess.run(
            compile_cmd,
            shell=True,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"[Party {self.party_id}] Compilation error:")
            print(result.stderr)
            raise RuntimeError("MPC program compilation failed")
        
        print(f"[Party {self.party_id}] Compilation successful")
        return True
    
    def run_party_async(self, program_name="secure_matmul", 
                       port_base=5000, timeout=60):
        """异步运行 MPC 参与方"""
        run_cmd = (
            f"cd {self.mpspdz_root} && "
            f"./semi2k-party.x -p {self.party_id} "
            f"-N 2 -pn {port_base} "
            f"{program_name}"
        )
        
        print(f"[Party {self.party_id}] Running MPC...")
        print(f"  Command: {run_cmd}")
        
        result = subprocess.run(
            run_cmd,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout
        )
        
        if result.returncode != 0:
            print(f"[Party {self.party_id}] Execution error:")
            print(result.stderr)
            raise RuntimeError("MPC execution failed")
        
        print(f"[Party {self.party_id}] MPC completed")
        return result
    
    def secure_matrix_multiply(self, A=None, B=None, W=None, 
                              compile_once=True, session_id=0, 
                              use_file_output=True):
        """
        安全计算 (A - B) * W
        
        Args:
            A: Party 0 的矩阵 (m, n)
            B: Party 1 的矩阵 (m, n)
            W: Party 0 的权重矩阵 (n, n)
            compile_once: 是否只编译一次
            session_id: 会话ID
            use_file_output: 是否使用文件输出（推荐True）
        """
        # 1. 准备输入
        if self.party_id == 0:
            if A is None or W is None:
                raise ValueError("Party 0 must provide A and W")
            m, n = A.shape
            self.write_inputs({'A': A, 'W': W}, session_id)
        else:
            if B is None:
                raise ValueError("Party 1 must provide B")
            m, n = B.shape
            self.write_inputs({'B': B}, session_id)
        
        # 2. 编译程序
        if not compile_once or session_id == 0:
            self.compile_program("secure_matmul")
        
        # 3. 清理旧的输出文件
        output_file = os.path.join(
            self.player_data_dir,
            f"Output-P{self.party_id}-{session_id}"
        )
        if os.path.exists(output_file):
            os.remove(output_file)
            print(f"[Party {self.party_id}] Removed old output file")
        
        # 4. 运行 MPC
        result = self.run_party_async("secure_matmul", port_base=5000)
        
        # 5. 读取结果
        try:
            if use_file_output:
                # 优先从文件读取
                print(f"[Party {self.party_id}] Reading from file...")
                output_tensor = self.read_outputs_from_file((m, n), session_id)
            else:
                # 从stdout读取
                print(f"[Party {self.party_id}] Reading from stdout...")
                output_tensor = self.read_outputs_from_stdout(result.stdout, (m, n))
            
            print(f"[Party {self.party_id}] Got result shape {output_tensor.shape}")
            return output_tensor
            
        except Exception as e:
            print(f"[Party {self.party_id}] Primary method failed: {e}")
            
            # 如果文件读取失败，尝试stdout
            if use_file_output:
                print(f"[Party {self.party_id}] Trying stdout as fallback...")
                try:
                    output_tensor = self.read_outputs_from_stdout(result.stdout, (m, n))
                    print(f"[Party {self.party_id}] Fallback successful!")
                    return output_tensor
                except Exception as e2:
                    print(f"[Party {self.party_id}] Fallback also failed: {e2}")
            
            print(f"[Party {self.party_id}] stdout (first 2000 chars):")
            print(result.stdout[:2000])
            print(f"\n[Party {self.party_id}] stderr (first 2000 chars):")
            print(result.stderr[:2000])
            raise
    
    def cleanup(self, session_id=0):
        """清理临时文件"""
        files = [
            f"Input-P{self.party_id}-{session_id}",
            f"Output-P{self.party_id}-{session_id}"
        ]
        
        for fname in files:
            fpath = os.path.join(self.player_data_dir, fname)
            if os.path.exists(fpath):
                os.remove(fpath)
                print(f"[Party {self.party_id}] Removed {fname}")


# 测试函数
if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--party', type=int, required=True, choices=[0, 1])
    parser.add_argument('--m', type=int, default=4)
    parser.add_argument('--n', type=int, default=4)
    parser.add_argument('--use_file', action='store_true', default=True,
                       help='Use file output (recommended)')
    args = parser.parse_args()
    
    print(f"\n{'='*60}")
    print(f"Testing MPC as Party {args.party}")
    print(f"Matrix size: {args.m}x{args.n}")
    print(f"Use file output: {args.use_file}")
    print(f"{'='*60}\n")
    
    mpc = MPSPDZManager(party_id=args.party)
    
    try:
        if args.party == 0:
            # Party 0
            A = torch.randn(args.m, args.n)
            W = torch.randn(args.n, args.n)
            print(f"Party 0 - A:\n{A}\n")
            print(f"Party 0 - W:\n{W}\n")
            
            result = mpc.secure_matrix_multiply(
                A=A, W=W, 
                use_file_output=args.use_file
            )
            print(f"\nParty 0 - Result:\n{result}")
            
        else:
            # Party 1
            B = torch.randn(args.m, args.n)
            print(f"Party 1 - B:\n{B}\n")
            
            result = mpc.secure_matrix_multiply(
                B=B,
                use_file_output=args.use_file
            )
            print(f"\nParty 1 - Result:\n{result}")
        
        print(f"\n{'='*60}")
        print("Test PASSED!")
        print(f"{'='*60}\n")
        
        # 清理
        mpc.cleanup()
        
    except Exception as e:
        print(f"\n{'='*60}")
        print(f"Test FAILED: {e}")
        import traceback
        traceback.print_exc()
        print(f"{'='*60}\n")
        raise